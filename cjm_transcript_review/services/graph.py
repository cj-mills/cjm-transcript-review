"""Graph service for committing documents and segments to the context graph"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/services/graph.ipynb.

# %% auto #0
__all__ = ['GraphService']

# %% ../../nbs/services/graph.ipynb #987b5cd3
from typing import List, Dict, Any, Optional
from uuid import uuid4
import asyncio

from cjm_plugin_system.core.manager import PluginManager
from cjm_graph_plugin_system.core import SourceRef
from cjm_graph_domains.domains.structure import Document, Segment
from cjm_graph_domains.domains.relations import StructureRelations

from cjm_transcript_segmentation.models import TextSegment
from cjm_transcript_vad_align.models import VADChunk

# %% ../../nbs/services/graph.ipynb #3be5680e
class GraphService:
    """Service for committing structure to context graph."""
    
    def __init__(
        self,
        plugin_manager:PluginManager,  # Plugin manager for accessing graph plugin
        plugin_name:str="cjm-graph-plugin-sqlite",  # Name of the graph plugin
    ):
        """Initialize the graph service."""
        self._manager = plugin_manager
        self._plugin_name = plugin_name
    
    def is_available(self) -> bool:  # True if plugin is loaded and ready
        """Check if the graph plugin is available."""
        return self._manager.get_plugin(self._plugin_name) is not None
    
    def ensure_loaded(
        self,
        config:Optional[Dict[str, Any]]=None,  # Optional plugin configuration
    ) -> bool:  # True if successfully loaded
        """Ensure the graph plugin is loaded."""
        if self.is_available():
            return True
        
        # Try to find and load the plugin
        meta = self._manager.get_discovered_meta(self._plugin_name)
        if meta:
            return self._manager.load_plugin(meta, config)
        return False
    
    def _create_source_ref(
        self,
        segment:TextSegment,  # Text segment with source info
    ) -> Optional[SourceRef]:  # SourceRef or None if no source info
        """Create a SourceRef from segment source information."""
        if not segment.source_id or not segment.source_provider_id:
            return None
        
        # Build segment slice string
        slice_str = None
        if segment.start_char is not None and segment.end_char is not None:
            slice_str = f"char:{segment.start_char}-{segment.end_char}"
        
        return SourceRef(
            plugin_name=segment.source_provider_id,
            table_name="transcriptions",
            row_id=segment.source_id,
            content_hash=SourceRef.compute_hash(segment.text.encode()),
            segment_slice=slice_str
        )
    
    async def commit_document_async(
        self,
        title:str,  # Document title
        text_segments:List[TextSegment],  # Text segments from decomposition
        vad_chunks:List[VADChunk],  # VAD chunks for timing (1:1 with segments)
        media_type:str="audio",  # Source media type
    ) -> Dict[str, Any]:  # Result with document_id and segment_ids
        """Commit a document to the context graph.
        
        Assembles text segments with VAD timing at commit time.
        Requires 1:1 alignment: len(text_segments) == len(vad_chunks).
        """
        if not self.is_available():
            raise RuntimeError(f"Plugin {self._plugin_name} not loaded")
        
        if len(text_segments) != len(vad_chunks):
            raise ValueError(
                f"Segment and VAD chunk counts must match: "
                f"{len(text_segments)} segments vs {len(vad_chunks)} chunks"
            )
        
        # Create Document node
        doc = Document(
            id=str(uuid4()),
            title=title,
            media_type=media_type
        )
        
        # Convert to graph node
        doc_node = doc.to_graph_node(sources=[])
        
        # Create Segment nodes by zipping text with timing
        segment_nodes = []
        for text_seg, vad_chunk in zip(text_segments, vad_chunks):
            seg = Segment(
                id=str(uuid4()),
                text=text_seg.text,
                index=text_seg.index,
                start_time=vad_chunk.start_time,
                end_time=vad_chunk.end_time,
                start_char=text_seg.start_char,
                end_char=text_seg.end_char
            )
            
            # Create source reference
            sources = []
            source_ref = self._create_source_ref(text_seg)
            if source_ref:
                sources.append(source_ref)
            
            segment_nodes.append(seg.to_graph_node(sources=sources))
        
        # Create edges
        edges = []
        
        # STARTS_WITH: Document -> First Segment
        if segment_nodes:
            edges.append({
                'id': str(uuid4()),
                'source_id': doc_node.id,
                'target_id': segment_nodes[0].id,
                'relation_type': StructureRelations.STARTS_WITH,
                'properties': {}
            })
        
        # PART_OF: Each Segment -> Document
        # NEXT: Each Segment -> Next Segment
        for i, seg_node in enumerate(segment_nodes):
            # PART_OF
            edges.append({
                'id': str(uuid4()),
                'source_id': seg_node.id,
                'target_id': doc_node.id,
                'relation_type': StructureRelations.PART_OF,
                'properties': {}
            })
            
            # NEXT (if not last segment)
            if i < len(segment_nodes) - 1:
                edges.append({
                    'id': str(uuid4()),
                    'source_id': seg_node.id,
                    'target_id': segment_nodes[i + 1].id,
                    'relation_type': StructureRelations.NEXT,
                    'properties': {}
                })
        
        # Convert nodes to dicts for serialization
        all_nodes = [doc_node.to_dict()] + [n.to_dict() for n in segment_nodes]
        
        # Add nodes to graph
        await self._manager.execute_plugin_async(
            self._plugin_name,
            action="add_nodes",
            nodes=all_nodes
        )
        
        # Add edges to graph
        await self._manager.execute_plugin_async(
            self._plugin_name,
            action="add_edges",
            edges=edges
        )
        
        return {
            'document_id': doc_node.id,
            'segment_ids': [n.id for n in segment_nodes],
            'edge_count': len(edges)
        }
    
    def commit_document(
        self,
        title:str,  # Document title
        text_segments:List[TextSegment],  # Text segments from decomposition
        vad_chunks:List[VADChunk],  # VAD chunks for timing
        media_type:str="audio",  # Source media type
    ) -> Dict[str, Any]:  # Result with document_id and segment_ids
        """Commit a document to the context graph synchronously."""
        return asyncio.get_event_loop().run_until_complete(
            self.commit_document_async(title, text_segments, vad_chunks, media_type)
        )
